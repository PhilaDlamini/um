static inline uint64_t shl(uint64_t word, unsigned bits)
{
        assert(bits <= 64);
        if (bits == 64)
                return 0;
        else
                return word << bits;
}

/*
 * shift R logical
 */
static inline uint64_t shr(uint64_t word, unsigned bits)
{
        assert(bits <= 64);
        if (bits == 64)
                return 0;
        else
                return word >> bits;
}



assert(width <= 64);
       unsigned hi = lsb + width; /* one beyond the most significant bit */
       assert(hi <= 64);
       if (!Bitpack_fitsu(value, width))
               RAISE(Bitpack_Overflow);
       return shl(shr(word, hi), hi)                 /* high part */
               | shr(shl(word, 64 - lsb), 64 - lsb)  /* low part  */
               | (value << lsb);                     /* new part  */
}


shl(shr(word, hi), hi)                 /* high part */
        | shr(shl(word, 64 - lsb), 64 - lsb)  /* low part  */
        | (value << lsb);

        shl(shr(word, (lsb + width))), lsb + width) | shr(shl(word, 32 - lsb), 64 - lsb) | (value << lsb)

        shl((word >> lsb + width)) | shr( (word << 32 - lsb), 32 - lsb) |
        ((word >> lsb + width) << lsb + width) |
